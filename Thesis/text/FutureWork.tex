The overall task of adding rewriting functionality to Agda is quite an exploratory 
project for a couple reasons, the most relevant being the unstable state of Agda's
standard library and, in particular, of the Reflection module. One workaround
is to define our own Term datatype, and, whenever Agda changes its reflection module,
we just need to fix the two converssion functions.

Our goal was not only adding automatic rewriting to Agda, but to explore how closely
to pen and paper we could model Relational Algebra in Agda. Disconsidering generic catamorphisms,
the result is very satisfactory. Agda runs in an aceptable time and allows us to build
some homework level proofs. When things got interesting though, that is, when we added (generic) catamorphisms to
the recipe, Agda did not behave that well. We encountered several performance problems
and \emph{internal error} messages. The code still works and is able to (poorly) handle
generic catamorphisms. From what we know, this is the first attempt at encoding relational generic catamorphisms
in Agda. It is interesting to know that it is, indeed, possible to develop an encoding using W-types. Yet,
work remains to be done in refining and fixing this approach. On this same note, the authors
can not help but wish Agda provided more control or information over evaluation (typechecking).
Some sort of profiling, for instance, would really help developers.

On another interesting digression, we did fix the relational equality problem, in Agda,
by using Homotopy Type Theory. Our fix still relies on one axiom, the Univalence Axiom.
It is arguable, however, on how much of that was indeed necessary, since by assuming
function extensionality one could already provide the proofs.
Nevertheless, we do believe it is very good practice to keep postulates to an absolute minimum. 
They not only block evaluation but can lead to inconsistencies if not carefully analized. 
It is also worth noting that our library had special specifications in mind, when it was designed.
Such as being suitable for automated processing. This constraint rendered a heavier library
in terms of code.

In parallel with the development of the aforementioned library, on a more practical front,
we developed a few tactics for automated context inference on equational reasoning proofs.
During a first iteration, the tactic was pretty straight forward and, once we figured out
the necessary \F{RTerm} operations, its implementation was relatively straight forward.
Generalizing it was a more complicated task. We did develop a data structure better than lists to
handle multiple possible actions, yet, the construction of such object in Agda posed a 
performance problem, which we did not have time to overcome and was left as future work.
Here again, a few debugging tools from Agda itself could be of great help.

