\begin{TODO}
  \item frame this thing
\end{TODO}

We're taking Relational Algebra\cite{Bird97} as our main case study for a couple of reasons. One of the most
important beeing it's expressive power and it's unquestionable advantage as a framework for
reasoning about software, in an equational fashion. Relational Algebra is in fact a discipline that
allows us to speak of software engineering through unambiguous equations, giving a definite meaning
to the \emph{engineering} part of software engineering.

Unlike most programming languages, an encoding of Relational Algebra in a dependently typed 
language allows one to truly see the advantage of dependent types in action. Most of the definitions
happens at the \emph{type level} (remember that there is no difference between types and values in Agda,
this is just a mnemonic to help understanting the \emph{functions}). The encoding presented
here is based on \cite{Jansson09}.

Long story short, a binary relation $R$ of type $A \rightarrow B$ can be thought of in terms of several mathematical objects.
The usual definition is to say that $R \subseteq A \times B$, where $\cdot\times\cdot$ is the cartesian product of sets.
In fact, $R$ contains pairs or related elements whose first component is of type $A$ and second component is of type $B$,
note that it is slightly more general than the concept of a function, where we can have $b_1\;R\;a$ and $b_2\;R\;a$, which means
that $(a, b_1) \in R$ and $(a, b_2) \in R$, as a perfectly valid relation, but not a function, since $a$ would be mapped to two different values, $b_1$ and $b_2$.

\newcommand{\powerset}{\mathcal{P}}
Another way of speaking about relations, though, is to consider functions of type $A \rightarrow \powerset B$.
If our previous $R$ was in fact a function $f$, we would then have $f\; a = \{b_1, b_2\}$. For the more
mathematically inclined reader, the arrows $A \rightarrow \powerset B$ in the category \catname{Sets}, of sets and
functions, correspond to arrows $A \rightarrow B$ in the category \catname{Rel}, of sets and relations. For this matter,
we actually call \catname{Rel} the Kleisli Category for the monad $\powerset$. 

For our Agda encoding of Relations, we shall use a slight modification of the $\powerset$ approach.
Let's begin, in fact, by encoding set theoretic notions. The most important of all beeing undoubtly
the membership notion $\cdot \in \cdot$. One way of encoding a subset of a set $A$ is using a function $f$
of type $A \rightarrow Bool$, the subset is obtained by $\{\; a \in A\; |\; f\;a\; \}$. Yet, in Agda, this would
force that we deal only with decidable domains, which is not a problem if everything is finite, but
for infinite domains this would not work.

Another option, which is the one used in \cite{Jansson09}, is to use a function $f$
of type $A \rightarrow \D{Set}$ to encode a subset of $A$. Remember that \D{Set} is
the type of types in Agda. Although not very intuitive, this is much more expressive than the 
last option and the induced subset would be defined by $\{\; a \in A\; | f\;a\;\text{is inhabited }\}$,
which would turn out to be:

\Agda{RelationsCore}{subset-def}

Extending from sets to binary relations is a very simple task. Besides the canonical steps,
we'll also swap the arguments for a relation, following what was done in \cite{Jansson09} and
keeping the syntax closer to what one would write on paper, since we usually writes a relational
statement from left to right, that is, $y\;R\;x$ means that $(x, y) \in R$.
\begin{eqnarray*}
  \powerset (A \times B) & = & \powerset (B \times A)\\
                         & = & B \times A \rightarrow \D{Set}\\
                         & = & B \rightarrow A \rightarrow \D{Set}
\end{eqnarray*}
Or, in Agda:

\Agda{RelationsCore}{relation-def}

Now we need to specify constructions that will allow us to define our relations. A couple simple
ones are:

\Agda{RelationsCore}{first-constructs}

And they're defined just as we would expect them. Note that \D{\_⊎\_} represents a disjoin union of sets
(equivalent to Either in Haskell) and \D{\_×\_} represents the usual cartesian product. The function
lifting might look like the less intuitive construction, but it's a very simple one. $fun\;f$ is a relation,
therefore it takes a $b$ and a $a$ and should return a type that is inhabited if and only if $(a, b) \in fun\;f$,
or, to put it another way, if $b = f\;a$, almost like it's textbook definition. The difference is in
Agda's propositional equality operator: \D{\_≡\_}.  


